<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Orville - Using SqlMarshaller</title>
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
      <section class="leftbar">
        <header>
          <h1 class="logo">
            <a href="../">
              <img alt="Orville Logo" src="../images/orville-waving-pennant.svg" />
            </a>
          </h1>
        </header>

        <nav>
          <h3><a href="../">Home</a></h3>

          <h3>Tutorials</h3>
          
            <a href="../tutorials/getting-started.html">Getting Started</a>
          
            <a href="../tutorials/using-sql-marshaller.html">Using SqlMarshaller</a>
          
            <a href="../tutorials/using-migrations.html">Using Migrations</a>
          
            <a href="../tutorials/using-plans.html">Using Plans</a>
          
            <a href="../tutorials/using-json.html">Using JSON</a>
          

          <h3>How-To Guides</h3>
          
            <a href="../how-tos/how-to-add-orville-to-your-application-monad.html">How To Add Orville to Your Application Monad</a>
          
            <a href="../how-tos/how-to-add-orville-to-an-existing-reader-context.html">How To Add Orville to an Existing Reader Context</a>
          
            <a href="../how-tos/how-to-marshall-a-haskell-record.html">How To Marshall a Haskell Record (Upcoming)</a>
          
            <a href="../how-tos/how-to-add-custom-marshalling-validations.html">How Add Custom Marshalling Validations (Upcoming)</a>
          
            <a href="../how-tos/how-to-marshall-a-haskell-sum-type.html">How To Marshall a Haskell Sum Type (Upcoming)</a>
          
            <a href="../how-tos/how-to-set-up-an-auto-incrementing-id-column.html">How To Set Up An Auto-incrementing Id Column (Upcoming)</a>
          
            <a href="../how-tos/how-to-execute-raw-sql.html">How To Execute Raw SQL (Upcoming)</a>
          

          <h3>Futher Explanation</h3>
          
            <a href="../explanations/the-monad-orville-typeclass.html">The MonadOrville Typeclass (Upcoming)</a>
          
            <a href="../explanations/building-sql-expressions.html">Building SQL Expressions (Upcoming)</a>
          
            <a href="../explanations/fighting-n-plus-one-queries-with-plans.html">Fighting N+1 Queries with Plans (Upcoming)</a>
          

          <h3>API Reference</h3>
          <a href="https://hackage.haskell.org/package/orville-postgresql">See Hackage</a>

          <h3>Other Links</h3>
          <a href="../contact.html">Contact</a>
        </nav>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
      </section>

      <main role="main">
        <h1>Using SqlMarshaller</h1>
        <article>
  <section>
    <p>The SQL Marshaller helps with converting from a Haskell record to SQL and back.
This document also shows how the SQL marshaller in table definitions, which can
then be used to generate Data Definition Language (DDL) queries to create
tables in the database.</p>
<p>You’ll need a Haskell project named <code>using-sql-marshaller</code> for this tutorial.
The setup is identical to the setup in <a href="getting-started.html">Getting Started</a>
aside from the package name, so we’ll avoid explaining it again here. Instead
we’ll get straight on creating our <code>src/Main.hs</code> file.</p>
<p>First, let’s import the necessary modules. We use less ‘internal’ imports here
than in the <a href="getting-started.html">Getting Started</a> guide, because we are using
a higher abstraction level.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ( main</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ) <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL</span> <span class="kw">as</span> <span class="dt">O</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL.AutoMigration</span> <span class="kw">as</span> <span class="dt">AutoMigration</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">Int</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Next, let’s declare some type aliases and the Haskell record itself. We’ll
enable storing values of this record in the SQL database.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FooId</span> <span class="ot">=</span> <span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FooName</span> <span class="ot">=</span> <span class="dt">T.Text</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FooAge</span> <span class="ot">=</span> <span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fooId ::</span> <span class="dt">FooId</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> fooName ::</span> <span class="dt">FooName</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> fooAge ::</span> <span class="dt">FooAge</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>To store the record in SQL, we need to define Orville FieldDefinitions for each
of the fields of the record. A FieldDefinition maps to a column in SQL. Also
note how the type is parameterized on whether it is nullable or not.</p>
<p>The strings passed in here are the actual SQL column names. FieldDefinitions
help avoiding typos, since the Haskell compiler will fail compilation if the
name of a FieldDefinition is misspelt.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fooIdField ::</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">FooId</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>fooIdField <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  O.integerField <span class="st">&quot;id&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fooNameField ::</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">FooName</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>fooNameField <span class="ot">=</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  O.unboundedTextField <span class="st">&quot;name&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fooAgeField ::</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">FooAge</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>fooAgeField <span class="ot">=</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  O.integerField <span class="st">&quot;age&quot;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Now that the fields are defined, we can use them, togehter with the record
field selector functions, to define the <code>SqlMarshaller</code>.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fooMarshaller ::</span> <span class="dt">O.SqlMarshaller</span> <span class="dt">Foo</span> <span class="dt">Foo</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>fooMarshaller <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Foo</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> O.marshallField fooId fooIdField</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> O.marshallField fooName fooNameField</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> O.marshallField fooAge fooAgeField</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>We can use the marshaller to define the Orville table definition. This binding
represents a table, but note that it doesn’t necessarily exist in the SQL
database until we start using it.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">table ::</span> <span class="dt">O.TableDefinition</span> (<span class="dt">O.HasKey</span> <span class="dt">FooId</span>) <span class="dt">Foo</span> <span class="dt">Foo</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>table <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  O.mkTableDefinition <span class="st">&quot;foo&quot;</span> (O.primaryKey fooIdField) fooMarshaller</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Now let’s write the main function, which does the following:
1. auto migrates using the table defintion. It will match the Haskell record at
the time of execution of the statement. The details of migration are out of
scope for this article.
1. deletes the Foo with ID 0, if it exists. Necessary to allow the program to
be repeatedly executed, as primary keys can’t be duplicated.
1. inserts an example Foo object with ID 0.
1. reads it back out using its ID 0. If an entity with the given ID doesn’t
exist, we’d get a Nothing here.
1. prints the retrieved entity</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  pool <span class="ot">&lt;-</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    O.createConnectionPool</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">O.ConnectionOptions</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>          { O.connectionString <span class="ot">=</span> <span class="st">&quot;host=localhost user=postgres password=postgres&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>          , O.connectionNoticeReporting <span class="ot">=</span> <span class="dt">O.DisableNoticeReporting</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolStripes <span class="ot">=</span> <span class="dt">O.OneStripePerCapability</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolLingerTime <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolMaxConnections <span class="ot">=</span> <span class="dt">O.MaxConnectionsPerStripe</span> <span class="dv">1</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  mbFoo <span class="ot">&lt;-</span> O.runOrville pool <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    AutoMigration.autoMigrateSchema AutoMigration.defaultOptions [<span class="dt">AutoMigration.SchemaTable</span> table]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">&lt;-</span> O.deleteEntity table <span class="dv">0</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">&lt;-</span> O.insertEntity table <span class="dt">Foo</span> { fooId <span class="ot">=</span> <span class="dv">0</span>, fooName <span class="ot">=</span> T.pack <span class="st">&quot;Name&quot;</span>, fooAge <span class="ot">=</span> <span class="dv">91</span> }</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    O.findEntity table <span class="dv">0</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> mbFoo</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>The program is now complete, let’s compile and run!</p>
<div class="codeblock-label">
shell
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> build</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> exec using-sql-marshaller</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Once it builds and runs successfully you should see the following output:</p>
<div class="codeblock-label">
output : plaintext
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>Just (Foo {fooId = 0, fooName = &quot;Name&quot;, fooAge = 91})</span></code></pre></div>
  </section>
</article>

      </main>
    </body>
</html>
